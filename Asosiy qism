# uno_bot.py
# Requirements: python-telegram-bot v20.3
# Run: python uno_bot.py
# Set TOKEN below.

import asyncio
import random
import sqlite3
from datetime import datetime, timedelta

from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    ChatPermissions,
)
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters,
)

# ====== CONFIG ======
TOKEN = "8204612687:AAHaM_Ho-D3SN3-uQlT-ZUFK6b9KTiKbKOo"
ALLOWED_GROUPS = (-1002884098351, -1002296190813)  # only these groups allowed
MAX_PLAYERS = 9
MIN_PLAYERS = 2
START_HAND_SIZE = 7
# ====================

# --------- SQLite (file) for storing users who pressed /start ----------
DB_PATH = "players.db"
conn = sqlite3.connect(DB_PATH, check_same_thread=False)
cur = conn.cursor()
cur.execute("CREATE TABLE IF NOT EXISTS users (user_id INTEGER PRIMARY KEY)")
conn.commit()


def add_user(user_id: int):
    cur.execute("INSERT OR IGNORE INTO users (user_id) VALUES (?)", (user_id,))
    conn.commit()


def user_exists(user_id: int) -> bool:
    cur.execute("SELECT user_id FROM users WHERE user_id = ?", (user_id,))
    return cur.fetchone() is not None


# --------- In-memory game storage ----------
CREATION_LOCK = {"active": False, "creator_id": None, "started_at": None, "expiry": None, "group_id": None}
GAMES = {}  # keyed by group_id


# --------- Deck & game helpers ----------
def create_deck_for_colors(color_pair):
    """Create realistic UNO deck but only for the selected two colors + wilds."""
    deck = []
    for color in color_pair:
        # 0
        deck.append({"type": "num", "color": color, "val": "0"})
        # 1..9 two copies each
        for v in range(1, 10):
            deck.append({"type": "num", "color": color, "val": str(v)})
            deck.append({"type": "num", "color": color, "val": str(v)})
        # action cards x2 each
        for _ in range(2):
            deck.append({"type": "+2", "color": color, "val": "+2"})
            deck.append({"type": "skip", "color": color, "val": "🚫"})
            deck.append({"type": "reverse", "color": color, "val": "🔁"})
    # wilds and +4 (colorless)
    for _ in range(4):
        deck.append({"type": "wild", "color": None, "val": "🔁"})
        deck.append({"type": "+4", "color": None, "val": "+4"})
    random.shuffle(deck)
    return deck


def new_game_struct(creator_id, creator_name, group_id, game_name):
    return {
        "creator_id": creator_id,
        "creator_name": creator_name,
        "group_id": group_id,
        "name": game_name,
        "color_pair": None,
        "players": [],  # dicts: id, first_name, last_name, username, hand:list, finished_at
        "deck": [],
        "discard": [],
        "current_color": None,
        "turn_index": 0,
        "direction": 1,
        "started": False,
        "created_at": datetime.utcnow(),
        "notified_no_dm": set(),  # track players already told to /start for this game
    }


def card_text(card):
    if not card:
        return ""
    if card["type"] == "num":
        return f"{card['color']}{card['val']}"
    if card["type"] in ("+2", "skip", "reverse"):
        return f"{card['color']}{card['val']}"
    return f"{card['val']}"


# --------- Messaging helpers ----------
async def send_hand_to_player(app, player, game):
    """Send the player's hand as inline buttons only if user_exists in DB.
       If user not in DB, notify the group (once per player per game)."""
    user_id = player["id"]
    # Check DB
    if not user_exists(user_id):
        # notify group only once per player per game
        if user_id not in game.get("notified_no_dm", set()):
            try:
                await app.bot.send_message(chat_id=game["group_id"],
                                           text=f"{player.get('first_name','Foydalanuvchi')} — iltimos botga shaxsiyda /start yuboring, shunda sizga kartalar yuboriladi.")
            except Exception:
                pass
            game["notified_no_dm"].add(user_id)
        return

    hand = player.get("hand", [])
    kb = []
    row = []
    for i, c in enumerate(hand):
        row.append(InlineKeyboardButton(text=card_text(c), callback_data=f"play:{game['group_id']}:{user_id}:{i}"))
        if len(row) == 4:
            kb.append(row)
            row = []
    if row:
        kb.append(row)
    # Draw & show buttons
    kb.append([InlineKeyboardButton("Olish (1 karta)", callback_data=f"draw:{game['group_id']}:{user_id}")])
    kb.append([InlineKeyboardButton("Qayta", callback_data=f"showhand:{game['group_id']}:{user_id}")])
    markup = InlineKeyboardMarkup(kb)
    # send zero-width text so only buttons appear visually
    try:
        await app.bot.send_message(chat_id=user_id, text="\u200b", reply_markup=markup)
    except Exception:
        # If DM fails even though user_exists (rare), tell group once
        if user_id not in game.get("notified_no_dm", set()):
            try:
                await app.bot.send_message(chat_id=game["group_id"],
                                           text=f"{player.get('first_name','Foydalanuvchi')}, bot sizga DM yubora olmadi. Iltimos botni shaxsiy chatda /start qiling va ruxsat bering.")
            except Exception:
                pass
            game["notified_no_dm"].add(user_id)


async def group_send(app, group_id, text, reply_markup=None):
    try:
        await app.bot.send_message(chat_id=group_id, text=text, reply_markup=reply_markup)
    except Exception:
        pass


# --------- Turn & play helpers ----------
def current_player(game):
    if not game["players"]:
        return None
    if game["turn_index"] >= len(game["players"]):
        game["turn_index"] = 0
    return game["players"][game["turn_index"]]


def advance_turn_index(game, steps=1):
    if not game["players"]:
        return 0
    n = len(game["players"])
    idx = game["turn_index"]
    for _ in range(steps):
        attempts = 0
        while True:
            idx = (idx + game["direction"]) % n
            if not game["players"][idx].get("finished_at"):
                break
            attempts += 1
            if attempts > n:
                break
    return idx


def is_play_legal(card, top_card, current_color):
    if card is None:
        return False
    if top_card is None:
        return True
    if card["type"] in ("wild", "+4"):
        return True
    if card.get("color") and current_color and card["color"] == current_color:
        return True
    if card["type"] == "num" and top_card.get("type") == "num" and card["val"] == top_card["val"]:
        return True
    return False


def deal_cards(game):
    deck = game["deck"]
    for p in game["players"]:
        p["hand"] = []
    for _ in range(START_HAND_SIZE):
        for p in game["players"]:
            if not deck:
                break
            p["hand"].append(deck.pop())
    # initial discard - avoid wild/+4 as first
    while game["deck"]:
        top = game["deck"].pop()
        if top["type"] in ("wild", "+4"):
            game["deck"].insert(0, top)
            continue
        game["discard"].append(top)
        game["current_color"] = top.get("color")
        break


def refill_deck_from_discard(game):
    if not game["deck"] and len(game["discard"]) > 1:
        top = game["discard"].pop()
        game["deck"] = game["discard"][:]
        random.shuffle(game["deck"])
        game["discard"] = [top]


def check_end_game(game):
    winners = [p for p in game["players"] if p.get("finished_at")]
    if len(winners) >= 3:
        return True
    alive = [p for p in game["players"] if not p.get("finished_at")]
    if len(alive) <= 1:
        return True
    return False


# --------- Handlers ----------
async def start_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    add_user(user.id)
    await update.message.reply_text("✅ Siz /start bosdingiz. Endi o'yinlarda kartalar shaxsiy xabarga yuborilishi mumkin.")


async def create_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # only private creation
    msg = update.message
    if msg.chat.type != "private":
        await msg.reply_text("O'yin yaratish faqat bot bilan shaxsiy chatda amalga oshiriladi.")
        return
    user = msg.from_user
    now = datetime.utcnow()
    if CREATION_LOCK["active"]:
        if CREATION_LOCK["creator_id"] == user.id:
            await msg.reply_text("Siz allaqachon o'yin yaratmoqdasiz. Davom eting.")
            return
        await msg.reply_text("Boshqa foydalanuvchi hozir o'yin yaratmoqda. Iltimos keyinroq urinib ko'ring.")
        return
    CREATION_LOCK.update({"active": True, "creator_id": user.id, "started_at": now, "expiry": now + timedelta(minutes=10), "group_id": None})
    context.user_data["creating"] = {"step": "await_name"}
    await msg.reply_text("O'yin nomini kiriting:")


async def private_message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    if msg.chat.type != "private":
        return
    creating = context.user_data.get("creating")
    if not creating:
        return
    step = creating.get("step")
    if step == "await_name":
        creating["game_name"] = msg.text.strip()[:80]
        creating["step"] = "await_color"
        kb = InlineKeyboardMarkup(
            [[InlineKeyboardButton("🔴🟡", callback_data="choosecolor:red_yellow"),
              InlineKeyboardButton("🔵🟢", callback_data="choosecolor:blue_green")]]
        )
        await msg.reply_text("Qaysi rang sxemasida o'ynaymiz?", reply_markup=kb)
        return
    if step == "await_group_id":
        text = msg.text.strip()
        try:
            group_id = int(text)
        except ValueError:
            await msg.reply_text("Iltimos to'g'ri guruh ID raqamini kiriting.")
            return
        if group_id not in ALLOWED_GROUPS:
            await msg.reply_text("Bu guruhda o'yin boshlashga ruxsat yo'q.")
            return
        user = msg.from_user
        game_name = creating.get("game_name", "O'yin")
        game = new_game_struct(user.id, f"{user.first_name} {user.last_name or ''}", group_id, game_name)
        chosen = creating.get("color_pair")
        if not chosen:
            await msg.reply_text("Rang sxemasi topilmadi. Iltimos /create dan qaytadan boshlang.")
            CREATION_LOCK.update({"active": False, "creator_id": None, "group_id": None})
            context.user_data.pop("creating", None)
            return
        game["color_pair"] = chosen
        game["deck"] = create_deck_for_colors(chosen)
        GAMES[group_id] = game
        CREATION_LOCK.update({"group_id": group_id, "active": False, "creator_id": None})
        kb = InlineKeyboardMarkup([[InlineKeyboardButton("🙂Qo'shilish", callback_data=f"join:{group_id}")]])
        try:
            await context.bot.send_message(chat_id=group_id, text=f"O'yin yaratildi: {game_name}\nQo'shilish uchun tugmani bosing.", reply_markup=kb)
            await msg.reply_text("O'yin guruhga jo'natildi. Guruhga qarang.")
        except Exception:
            await msg.reply_text("Guruhga xabar yuborib bo'lmadi. Iltimos botni guruhga qo'shing va ruxsat bering.")
            GAMES.pop(group_id, None)
            CREATION_LOCK.update({"group_id": None, "active": False, "creator_id": None})
        context.user_data.pop("creating", None)
        return


async def callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    user = query.from_user

    # choosecolor
    if data.startswith("choosecolor:"):
        key = data.split(":", 1)[1]
        creating = context.user_data.get("creating")
        if not creating or creating.get("step") != "await_color":
            await query.edit_message_text("Yaratish jarayoni topilmadi yoki bekor qilingan.")
            return
        if key == "red_yellow":
            colors = ["🔴", "🟡"]
        else:
            colors = ["🔵", "🟢"]
        creating["color_pair"] = colors
        creating["step"] = "await_group_id"
        await query.edit_message_text(f"Rang sxemasi tanlandi: {''.join(colors)}\nEndi guruh ID ni kiriting (faqat ruxsat berilgan guruhlar): {ALLOWED_GROUPS}")
        return

    # join
    if data.startswith("join:"):
        _, gid = data.split(":")
        group_id = int(gid)
        game = GAMES.get(group_id)
        if not game:
            await query.answer("Bu o'yin mavjud emas.", show_alert=True)
            return
        if any(p["id"] == user.id for p in game["players"]):
            await query.answer("Siz allaqachon o'yinga qo'shilgansiz.")
            return
        if len(game["players"]) >= MAX_PLAYERS:
            await query.answer("O'yinga maksimal odam qo'shildi.")
            return
        game["players"].append({
            "id": user.id,
            "first_name": user.first_name or "",
            "last_name": user.last_name or "",
            "username": user.username or "",
            "hand": [],
            "finished_at": None,
        })
        await group_send(context.application, group_id, f"✔️O'yinga {user.full_name} qo'shildi")
        await query.answer("Siz o'yinga qo'shildingiz.")
        if len(game["players"]) >= MAX_PLAYERS and not game["started"]:
            await begin_game(group_id, context.application)
        return

    # showhand
    if data.startswith("showhand:"):
        _, gid, uid = data.split(":")
        group_id = int(gid); user_id = int(uid)
        game = GAMES.get(group_id)
        if not game:
            await query.answer("O'yin topilmadi.")
            return
        player = next((p for p in game["players"] if p["id"] == user_id), None)
        if not player:
            await query.answer("Siz bu o'yinda yo'q ekansiz.")
            return
        await send_hand_to_player(context.application, player, game)
        await query.answer()
        return

    # draw
    if data.startswith("draw:"):
        _, gid, uid = data.split(":")
        group_id = int(gid); user_id = int(uid)
        game = GAMES.get(group_id)
        if not game:
            await query.answer("O'yin topilmadi.")
            return
        player = next((p for p in game["players"] if p["id"] == user_id), None)
        if not player:
            await query.answer("Siz bu o'yinda yo'q ekansiz.")
            return
        if not game["deck"]:
            refill_deck_from_discard(game)
        if not game["deck"]:
            await query.answer("Koloda bo'sh.")
            return
        player["hand"].append(game["deck"].pop())
        await send_hand_to_player(context.application, player, game)
        await query.answer("Sizga 1 karta olindi.")
        return

    # play
    if data.startswith("play:"):
        _, gid, uid, cidx = data.split(":")
        group_id = int(gid); user_id = int(uid); card_index = int(cidx)
        game = GAMES.get(group_id)
        if not game:
            await query.answer("O'yin topilmadi.", show_alert=True)
            return
        curr = current_player(game)
        if not curr or curr["id"] != user_id:
            await query.answer("Bu sizning navbatingiz emas.", show_alert=True)
            return
        player = curr
        if card_index < 0 or card_index >= len(player["hand"]):
            await query.answer("Karta topilmadi.", show_alert=True)
            return
        card = player["hand"][card_index]
        top_card = game["discard"][-1] if game["discard"] else None
        current_color = game.get("current_color", top_card["color"] if top_card and top_card.get("color") else None)
        if not is_play_legal(card, top_card, current_color):
            await query.answer("Siz buni qila olmaysiz.", show_alert=True)
            return

        played = player["hand"].pop(card_index)
        game["discard"].append(played)
        if played.get("color"):
            game["current_color"] = played["color"]
        else:
            game["current_color"] = None

        discard_text = " , ".join(card_text(c) for c in game["discard"])
        await group_send(context.application, group_id, f"{player['first_name']} {player.get('last_name','')} o'ynadi: {card_text(played)}\nTashlangan kartalar:\n{discard_text}")

        # Effects
        if played["type"] == "num":
            if not player["hand"]:
                player["finished_at"] = datetime.utcnow()
                await group_send(context.application, group_id, f"🏆 {player['first_name']} g'olib bo'ldi (kartalari tugadi)!")
                if check_end_game(game):
                    await finish_game(group_id, context.application)
                    await query.answer("Karta o'ynaldi.")
                    return
            game["turn_index"] = advance_turn_index(game, 1)
            await check_and_notify_hands(context.application, game)
            await query.answer("Karta o'ynaldi.")
            return

        if played["type"] == "skip":
            game["turn_index"] = advance_turn_index(game, 2)
            await check_and_notify_hands(context.application, game)
            await query.answer("Keyingi o'yinchi skip qilindi.")
            return

        if played["type"] == "reverse":
            game["direction"] *= -1
            if len([p for p in game["players"] if not p.get("finished_at")]) == 2:
                game["turn_index"] = advance_turn_index(game, 2)
            else:
                game["turn_index"] = advance_turn_index(game, 1)
            await check_and_notify_hands(context.application, game)
            await query.answer("Yo'nalish o'zgardi.")
            return

        if played["type"] == "+2":
            next_idx = advance_turn_index(game, 1)
            target = game["players"][next_idx]
            cards_given = []
            for _ in range(2):
                if not game["deck"]:
                    refill_deck_from_discard(game)
                if game["deck"]:
                    cards_given.append(game["deck"].pop())
            target["hand"].extend(cards_given)
            # try DM for target (only if exists in DB)
            try:
                if user_exists(target["id"]):
                    await context.application.bot.send_message(target["id"], f"Sizga +2 kartalar berildi: {', '.join(card_text(c) for c in cards_given)}")
                else:
                    if target["id"] not in game.get("notified_no_dm", set()):
                        await context.application.bot.send_message(game["group_id"], f"{target.get('first_name','Foydalanuvchi')}, iltimos botga shaxsiyda /start yuboring.")
                        game["notified_no_dm"].add(target["id"])
            except Exception:
                # notify group if DM fails
                if target["id"] not in game.get("notified_no_dm", set()):
                    try:
                        await context.application.bot.send_message(game["group_id"], f"{target.get('first_name','Foydalanuvchi')}, bot sizga DM yubora olmadi. /start qiling.")
                    except Exception:
                        pass
                    game["notified_no_dm"].add(target["id"])
            game["turn_index"] = advance_turn_index(game, 2)
            await check_and_notify_hands(context.application, game)
            await query.answer("+2 ta karta berildi va navbat o'tkazildi.")
            return

        if played["type"] == "+4":
            next_idx = advance_turn_index(game, 1)
            target = game["players"][next_idx]
            cards_given = []
            for _ in range(4):
                if not game["deck"]:
                    refill_deck_from_discard(game)
                if game["deck"]:
                    cards_given.append(game["deck"].pop())
            target["hand"].extend(cards_given)
            # DM or notify group
            try:
                if user_exists(target["id"]):
                    await context.application.bot.send_message(target["id"], f"Sizga +4 kartalar berildi: {', '.join(card_text(c) for c in cards_given)}")
                else:
                    if target["id"] not in game.get("notified_no_dm", set()):
                        await context.application.bot.send_message(game["group_id"], f"{target.get('first_name','Foydalanuvchi')}, iltimos botga shaxsiyda /start yuboring.")
                        game["notified_no_dm"].add(target["id"])
            except Exception:
                if target["id"] not in game.get("notified_no_dm", set()):
                    try:
                        await context.application.bot.send_message(game["group_id"], f"{target.get('first_name','Foydalanuvchi')}, bot sizga DM yubora olmadi. /start qiling.")
                    except Exception:
                        pass
                    game["notified_no_dm"].add(target["id"])
            # skip the target -> move turn to after target
            game["turn_index"] = next_idx
            game["turn_index"] = advance_turn_index(game, 1)
            await check_and_notify_hands(context.application, game)
            await query.answer("Karta o'ynaldi. Siz rangni tanlashingiz kerak.")
            # ask color privately (creator-chosen color_pair)
            colors = game["color_pair"]
            kb = InlineKeyboardMarkup([
                [InlineKeyboardButton(colors[0], callback_data=f"setcolor:{group_id}:{player['id']}:{colors[0]}"),
                 InlineKeyboardButton(colors[1], callback_data=f"setcolor:{group_id}:{player['id']}:{colors[1]}")]
            ])
            try:
                if user_exists(player["id"]):
                    await context.application.bot.send_message(chat_id=player["id"], text="Qaysi rangga almashtiramiz? (+4)", reply_markup=kb)
                else:
                    if player["id"] not in game.get("notified_no_dm", set()):
                        await context.application.bot.send_message(game["group_id"], f"{player.get('first_name','Foydalanuvchi')}, /start yuboring, keyin rang tanlash xususiyda keladi.")
                        game["notified_no_dm"].add(player["id"])
            except Exception:
                game["notified_no_dm"].add(player["id"])
            return

        if played["type"] == "wild":
            # advance now; color choice via DM
            game["turn_index"] = advance_turn_index(game, 1)
            await check_and_notify_hands(context.application, game)
            await query.answer("Rangni tanlang.")
            colors = game["color_pair"]
            kb = InlineKeyboardMarkup([
                [InlineKeyboardButton(colors[0], callback_data=f"setcolor:{group_id}:{player['id']}:{colors[0]}"),
                 InlineKeyboardButton(colors[1], callback_data=f"setcolor:{group_id}:{player['id']}:{colors[1]}")]
            ])
            try:
                if user_exists(player["id"]):
                    await context.application.bot.send_message(chat_id=player["id"], text="Qaysi rangga almashtiramiz?", reply_markup=kb)
                else:
                    if player["id"] not in game.get("notified_no_dm", set()):
                        await context.application.bot.send_message(game["group_id"], f"{player.get('first_name','Foydalanuvchi')}, /start yuboring.")
                        game["notified_no_dm"].add(player["id"])
            except Exception:
                game["notified_no_dm"].add(player["id"])
            return

        # fallback after play
        if player["hand"] == []:
            player["finished_at"] = datetime.utcnow()
            await group_send(context.application, group_id, f"🏆 {player['first_name']} g'olib bo'ldi (kartalari tugadi)!")
        game["turn_index"] = advance_turn_index(game, 1)
        await check_and_notify_hands(context.application, game)
        if check_end_game(game):
            await finish_game(group_id, context.application)
        await query.answer("Karta o'ynaldi.")
        return

    # setcolor
    if data.startswith("setcolor:"):
        _, gid, uid, color_choice = data.split(":")
        group_id = int(gid)
        user_id = int(uid)
        game = GAMES.get(group_id)
        if not game:
            await query.answer("O'yin topilmadi.")
            return
        game["current_color"] = color_choice
        await group_send(context.application, group_id, f"{color_choice} rangiga almashtirildi.")
        await check_and_notify_hands(context.application, game)
        await query.answer("Rang tanlandi.")
        return


async def check_and_notify_hands(app, game):
    for p in game["players"]:
        if p.get("finished_at"):
            continue
        await send_hand_to_player(app, p, game)
    curr = current_player(game)
    if curr:
        discard_text = " , ".join(card_text(c) for c in game["discard"])
        await group_send(app, game["group_id"], f"Hozir navbat: {curr['first_name']} {curr.get('last_name','')}. Tashlangan: {discard_text}")


async def begin_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    if msg.chat.type == "private":
        await msg.reply_text("Guruh chatida /begin yuboring.")
        return
    group_id = msg.chat.id
    if group_id not in ALLOWED_GROUPS:
        await msg.reply_text("Bu guruh uchun ruxsat yo'q.")
        return
    game = GAMES.get(group_id)
    if not game:
        await msg.reply_text("Bu guruhda o'yin yaratilmadi. Private /create orqali o'yin yarating.")
        return
    if game["started"]:
        await msg.reply_text("O'yin allaqachon boshlangan.")
        return
    if len(game["players"]) < MIN_PLAYERS:
        await msg.reply_text(f"O'yinni boshlash uchun kamida {MIN_PLAYERS} o'yinchi kerak.")
        return
    await begin_game(group_id, context.application)
    await msg.reply_text("O'yin boshlandi.")


async def begin_game(group_id, app):
    game = GAMES.get(group_id)
    if not game:
        return
    if not game.get("deck"):
        if game.get("color_pair"):
            game["deck"] = create_deck_for_colors(game["color_pair"])
        else:
            game["deck"] = create_deck_for_colors(["🔴", "🟡"])
    game["discard"] = []
    game["started"] = True
    game["direction"] = 1
    game["turn_index"] = 0
    deal_cards(game)
    await check_and_notify_hands(app, game)
    await group_send(app, group_id, f"O'yin boshlandi! O'yinchilar soni: {len(game['players'])}")


async def stop_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    if msg.chat.type == "private":
        await msg.reply_text("O'yinni to'xtatish guruhda /stop yuboring.")
        return
    group_id = msg.chat.id
    if group_id not in ALLOWED_GROUPS:
        await msg.reply_text("Bu guruh uchun ruxsat yo'q.")
        return
    game = GAMES.get(group_id)
    if not game:
        await msg.reply_text("Bu guruhda o'yin yo'q.")
        return
    await finish_game(group_id, context.application, manual=True)
    await msg.reply_text("O'yin to'xtatildi.")


async def finish_game(group_id, app, manual=False):
    game = GAMES.get(group_id)
    if not game:
        return
    winners = sorted([p for p in game["players"] if p.get("finished_at")], key=lambda x: x["finished_at"])
    lines = []
    if manual:
        lines.append("O'yin administrator tomonidan to'xtatildi.")
    else:
        lines.append("O'yin tugadi!")
    if winners:
        lines.append("G'oliblarimiz:")
        for i, w in enumerate(winners[:3], start=1):
            lines.append(f"{i}. {w['first_name']} {w.get('last_name','')}")
    else:
        lines.append("Hali hech kim g'olib bo'lmadi.")
    lines.append("Qolganlarga omad tilaymiz!")
    await group_send(app, group_id, "\n".join(lines))
    GAMES.pop(group_id, None)
    if CREATION_LOCK.get("group_id") == group_id:
        CREATION_LOCK.update({"active": False, "creator_id": None, "group_id": None})


async def games_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    txt = "Active games:\n"
    for gid, g in GAMES.items():
        txt += f"- {g['name']} in {gid} players:{len(g['players'])} started:{g['started']}\n"
    await update.message.reply_text(txt or "No active games.")


async def periodic_cleanup(app):
    while True:
        now = datetime.utcnow()
        if CREATION_LOCK.get("active") and CREATION_LOCK.get("expiry") and now > CREATION_LOCK["expiry"]:
            CREATION_LOCK.update({"active": False, "creator_id": None, "group_id": None})
        await asyncio.sleep(30)


# Anti-spam: delete non-! messages during active game and mute 1 minute
async def group_message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    if not msg or not msg.text:
        return
    chat = msg.chat
    user = msg.from_user
    if chat.type not in ("group", "supergroup"):
        return
    if chat.id not in ALLOWED_GROUPS:
        return
    game = GAMES.get(chat.id)
    if not game or not game.get("started"):
        return
    if user.is_bot:
        return
    text = msg.text.strip()
    if text.startswith("!"):
        return
    # admin/creator skip
    try:
        member = await context.bot.get_chat_member(chat.id, user.id)
        if member.status in ("administrator", "creator"):
            return
    except Exception:
        return
    # delete and mute 1 minute
    try:
        await msg.delete()
    except Exception:
        pass
    try:
        until = datetime.utcnow() + timedelta(minutes=1)
        await context.bot.restrict_chat_member(chat_id=chat.id, user_id=user.id,
                                               permissions=ChatPermissions(can_send_messages=False),
                                               until_date=until)
    except Exception:
        pass


# --------- Entry point ----------
def main():
    app = ApplicationBuilder().token(TOKEN).build()

    app.add_handler(CommandHandler("start", start_cmd))
    app.add_handler(CommandHandler("create", create_cmd))
    app.add_handler(CommandHandler("begin", begin_cmd))
    app.add_handler(CommandHandler("stop", stop_cmd))
    app.add_handler(CommandHandler("games", games_cmd))

    app.add_handler(CallbackQueryHandler(callback_handler))

    app.add_handler(MessageHandler(filters.TEXT & filters.ChatType.PRIVATE, private_message_handler))
    app.add_handler(MessageHandler(filters.TEXT & (filters.ChatType.GROUP | filters.ChatType.SUPERGROUP), group_message_handler))

    # periodic cleanup (use loop.create_task for PTB 20.3 compatibility)
    loop = asyncio.get_event_loop()
    loop.create_task(periodic_cleanup(app))

    print("Bot ishga tushdi...")
    app.run_polling()


if __name__ == "__main__":
    main()